# URL Query String Testing System - Design Document

**Project:** Bookslot (Extensible to all projects)  
**Author:** Framework Architecture Team  
**Date:** February 19, 2026  
**Status:** Design Phase  

---

## ğŸ“‹ Table of Contents

1. [Problem Statement](#problem-statement)
2. [Requirements Analysis](#requirements-analysis)
3. [Architecture Design](#architecture-design)
4. [Data Structure Design](#data-structure-design)
5. [Implementation Approaches](#implementation-approaches)
6. [Recommended Solution](#recommended-solution)
7. [Configuration Examples](#configuration-examples)
8. [Usage Patterns](#usage-patterns)
9. [Scalability & Extensibility](#scalability--extensibility)
10. [Migration Path](#migration-path)

---

## ğŸ¯ Problem Statement

### Current Challenge

The Bookslot project requires testing multiple URL combinations with:
- **Workflow IDs**: Up to 6 different IDs (different per environment)
- **Query Parameters**: 4+ parameters (flexible count)
- **Environments**: Staging and Production with different values
- **Combinations**: All possible combinations need testing

### Example Scenario

**Staging URLs:**
```
https://bookslot-staging.example.com/page?workflow_id=WF001&param1=value1&param2=value2
https://bookslot-staging.example.com/page?workflow_id=WF002&param1=value1&param2=value3
... (hundreds of combinations)
```

**Production URLs:**
```
https://bookslot-production.example.com/page?workflow_id=PROD_WF001&param1=valueA&param2=valueB
```

### Business Goals

1. **Coverage**: Test all valid URL combinations
2. **Efficiency**: Avoid redundant configurations
3. **Maintainability**: Easy to add/remove parameters
4. **Reusability**: Extend to other projects (not just Bookslot)
5. **Environment Awareness**: Different configs per environment

---

## ğŸ“Š Requirements Analysis

### Project-Specific Context

**Bookslot Project Specifics:**
- **Environments**: Only 2 environments (Staging & Production)
- **Test Data Approach**: Primary source is manual test data (Excel/CSV/JSON)
- **Auto-Generation**: Secondary/optional - only when needed
- **Workflow IDs**: Provided in test data, injected into URLs
- **Query Parameters**: Provided in test data, not auto-generated by default
- **Current URL Format**: Query string based (`domain.com/page?workflow_id=X&param1=Y`)
- **Future Flexibility**: Must support path-based URLs if needed

### Functional Requirements (Updated Based on Feedback)

#### Core Requirements (Must Have)

1. **FR-1: Environment-Specific Configurations** âœ… REQUIRED
   - **Current Need**: Support 2 environments only (staging, production)
   - **Implementation**: Environment-specific base URLs, no QA/UAT needed
   - **Source**: Configuration file or environment variables
   - **Example**: 
     - Staging: `https://bookslot-staging.centerforvein.com`
     - Production: `https://bookslot.centerforvein.com`

2. **FR-2: Dynamic Workflow ID Injection** âœ… REQUIRED
   - **Current Need**: Workflow IDs provided in test data, inject into URL
   - **Implementation**: Read workflow ID from test data row, inject into URL template
   - **Source**: Test data file (Excel, CSV, JSON, YAML)
   - **Example**: Test data has `workflow_id=WF001`, URL becomes `?workflow_id=WF001`

3. **FR-3: Multiple Query Parameters** âœ… REQUIRED
   - **Current Need**: Query parameters provided in test data (not auto-generated)
   - **Implementation**: Read all query params from test data, append to URL
   - **Source**: Test data file columns/fields
   - **Example**: Test data has `language=en, source=web`, URL becomes `?workflow_id=X&language=en&source=web`

4. **FR-4: Hybrid Mode - Manual + Auto Generation** âœ… REQUIRED
   - **Primary Mode**: Use test data as provided (manual)
   - **Secondary Mode**: Auto-generate combinations IF needed
   - **Implementation**: Support both modes seamlessly
   - **Decision Logic**:
     - If test data file exists â†’ Use manual data
     - If test file specifies `@auto_generate` â†’ Generate combinations
     - If CLI flag `--mode=auto` â†’ Generate combinations
   - **Example**: Test can choose: load from Excel OR generate 100 combinations

5. **FR-7: URL Validation Before Testing** âœ… REQUIRED
   - **Current Need**: Validate URLs work properly in browser
   - **Validation Levels**:
     - **Level 1**: HTTP 200 status code (basic)
     - **Level 2**: Specific element visible (e.g., h1, form)
     - **Level 3**: No error messages displayed
     - **Level 4**: All of the above (comprehensive) â† **REQUIRED**
   - **Implementation**: Pre-test validation step before actual test execution
   - **Example**: Before running test, verify URL loads and shows booking form

6. **FR-8: Flexible URL Templates** âœ… REQUIRED
   - **Current Format**: Query string based (`domain.com/page?workflow_id=X&param1=Y`)
   - **Future Support**: Path-based (`domain.com/workflow/X?param1=Y`)
   - **Implementation**: Template system with placeholders
   - **Examples**:
     - Query string: `{base_url}/booking?workflow_id={workflow_id}&{query_params}`
     - Path-based: `{base_url}/workflow/{workflow_id}/booking?{query_params}`
     - Hybrid: `{base_url}/{workflow_id}?{query_params}`

#### Optional Requirements (Nice to Have)

5. **FR-5: Parameter Dependencies** âš ï¸ OPTIONAL (Future)
   - **Current Need**: Not needed now, but system should support if condition arises
   - **Implementation**: Dependency rules in config file (if needed later)
   - **Example**: If `priority=emergency` then `source=web` (not needed currently)
   - **Status**: Design with hooks for future implementation

6. **FR-6: Parameter Exclusions** âš ï¸ OPTIONAL (Future)
   - **Current Need**: Not needed now, but system should support if needed
   - **Implementation**: Exclusion rules in config file (if needed later)
   - **Example**: Exclude `source=mobile` AND `patient_type=vip` (not needed currently)
   - **Status**: Design with extensibility for future needs

### Test Data Format Requirements

**Primary Requirement**: Support multiple test data formats

| Format | Priority | Use Case | Who Edits |
|--------|----------|----------|-----------|
| **Excel (.xlsx)** | HIGH | Easy for non-technical users | QA, BA, PM |
| **CSV (.csv)** | HIGH | Simple, version-controllable | Developers, QA |
| **JSON (.json)** | MEDIUM | Structured, API-friendly | Developers |
| **YAML (.yaml)** | MEDIUM | Human-readable, config-style | Developers |
| **Database** | LOW | Large datasets | Automated systems |

**Test Data Structure Example:**

```excel
# bookslot_test_data.xlsx

| workflow_id | environment | language | source | patient_type | insurance_verified | utm_campaign | expected_result |
|-------------|-------------|----------|--------|--------------|-------------------|--------------|-----------------|
| WF001       | staging     | en       | web    | new          | true              | summer_promo | success         |
| WF002       | staging     | es       | mobile | returning    | false             | default      | success         |
| WF003       | staging     | en       | tablet | vip          | true              | urgent_care  | success         |
```

### URL Format Requirements

**Current Requirement**: Query string based
**Future Requirement**: Support all formats

| Format Type | URL Pattern | Current Status | Example |
|-------------|-------------|----------------|---------|
| **Query String** | `domain.com/page?workflow_id=X&param=Y` | âœ… REQUIRED NOW | `bookslot.com?workflow_id=WF001&lang=en` |
| **Path Parameter** | `domain.com/workflow/X?param=Y` | ğŸ”® FUTURE | `bookslot.com/workflow/WF001?lang=en` |
| **Path-Based** | `domain.com/X/booking?param=Y` | ğŸ”® FUTURE | `bookslot.com/WF001/booking?lang=en` |
| **Hybrid** | `domain.com/X?param=Y` | ğŸ”® FUTURE | `bookslot.com/WF001?lang=en` |

**Implementation Strategy**: Use template system that supports all formats

### Non-Functional Requirements

1. **NFR-1**: Configuration should be YAML/JSON based (not hardcoded)
2. **NFR-2**: Should integrate with pytest parametrization
3. **NFR-3**: Should support data-driven testing patterns
4. **NFR-4**: Should be project-agnostic (reusable)
5. **NFR-5**: Should generate clear test names for reporting
6. **NFR-6**: Should support filtering (run specific combinations only)

### Bookslot Specific Requirements

1. **6 Workflow IDs** per environment (staging/production)
2. **4+ Query Parameters** with multiple values each
3. **Environment-specific values** for all parameters
4. **All combinations** need testing (cartesian product)

---

## ğŸ—ï¸ Architecture Design (HYBRID APPROACH)

### Design Principles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         MODERN AUTOMATION ARCHITECTURE PRINCIPLES           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Separation of Concerns: Data â‰  Logic â‰  Tests            â”‚
â”‚ 2. Data-Driven Primary: Test data files preferred          â”‚
â”‚ 3. Configuration Fallback: YAML/JSON when data not providedâ”‚
â”‚ 4. DRY: Don't Repeat Yourself - reusable components        â”‚
â”‚ 5. SOLID Principles: Single responsibility per class       â”‚
â”‚ 6. Factory Pattern: Create complex objects easily          â”‚
â”‚ 7. Builder Pattern: Construct URLs step-by-step            â”‚
â”‚ 8. Strategy Pattern: Multiple data source strategies       â”‚
â”‚ 9. Hybrid Flexibility: Support manual + auto modes         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### High-Level Architecture (HYBRID)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     URL Testing System (HYBRID)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      TEST LAYER                                â”‚  â”‚
â”‚  â”‚   (tests/bookslot/test_booking_workflow.py)                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                                         â”‚
â”‚                             â†“                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              URL DATA MANAGER (Router / Orchestrator)          â”‚  â”‚
â”‚  â”‚  - Detect mode (manual / auto / CLI flag)                      â”‚  â”‚
â”‚  â”‚  - Route to appropriate data source                            â”‚  â”‚
â”‚  â”‚  - Return standardized URL test cases                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                   â”‚                         â”‚
â”‚         â†“ (PRIMARY)                         â†“ (SECONDARY/FALLBACK)   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  TEST DATA LOADER    â”‚          â”‚  CONFIG-DRIVEN GENERATOR     â”‚  â”‚
â”‚  â”‚  - Excel (.xlsx)     â”‚          â”‚  - YAML config               â”‚  â”‚
â”‚  â”‚  - CSV (.csv)        â”‚          â”‚  - Auto-generate combos      â”‚  â”‚
â”‚  â”‚  - JSON (.json)      â”‚          â”‚  - Cartesian product         â”‚  â”‚
â”‚  â”‚  - YAML (.yaml)      â”‚          â”‚  - Pairwise optimization     â”‚  â”‚
â”‚  â”‚                      â”‚          â”‚  - Dependency rules          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                  â”‚                          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                      â†“                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    URL BUILDER                                 â”‚  â”‚
â”‚  â”‚  - Apply URL templates (query string, path-based, etc.)        â”‚  â”‚
â”‚  â”‚  - Inject workflow_id and parameters                           â”‚  â”‚
â”‚  â”‚  - Build final URLs ready for testing                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â†“                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                 URL VALIDATOR (Comprehensive)                  â”‚  â”‚
â”‚  â”‚  - Level 1: HTTP 200 status check                              â”‚  â”‚
â”‚  â”‚  - Level 2: Expected element presence                          â”‚  â”‚
â”‚  â”‚  - Level 3: No error messages on page                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â†“                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    PYTEST TEST RUNNER                          â”‚  â”‚
â”‚  â”‚  - Execute test logic for each URL                             â”‚  â”‚
â”‚  â”‚  - Assert expectations                                          â”‚  â”‚
â”‚  â”‚  - Generate comprehensive reports                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Mode Selection Decision Tree

```
User Initiates Test
        â”‚
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Check CLI Flag                          â”‚
â”‚  --mode=manual  OR  --mode=auto                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ manual                  â”‚ auto
         â†“                         â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Load Test    â”‚         â”‚ Generate from    â”‚
  â”‚ Data File    â”‚         â”‚ Config           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Check Test Decorator (if no CLI flag)   â”‚
â”‚  @pytest.mark.url_mode("manual") or ("auto")      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ manual                  â”‚ auto
         â†“                         â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Load Test    â”‚         â”‚ Generate from    â”‚
  â”‚ Data File    â”‚         â”‚ Config           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Auto-Detect (default if nothing set)    â”‚
â”‚  Check if test data file exists                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ exists                  â”‚ not exists
         â†“                         â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Load Test    â”‚         â”‚ Check if config  â”‚
  â”‚ Data File    â”‚         â”‚ file exists      â”‚
  â”‚ (MANUAL MODE)â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚ exists  â”‚ not exists
                                    â†“         â†“
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ Generate     â”‚ â”‚ ERROR  â”‚
                            â”‚ from Config  â”‚ â”‚ No dataâ”‚
                            â”‚ (AUTO MODE)  â”‚ â”‚ source â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Component Breakdown with Implementation Details

#### 1. URL Data Manager (NEW - Central Router)
**Purpose**: Orchestrates data source selection and routing
**Responsibility**: Decide mode, route to appropriate data source

```python
class URLDataManager:
    """
    Central manager for URL test data.
    Decides whether to load manual data or auto-generate based on:
    1. CLI flag (--mode=manual or --mode=auto)
    2. Test decorator (@pytest.mark.url_mode("manual"))
    3. Auto-detection (check if test data file exists)
    """
    
    def __init__(self, project: str, environment: str):
        self.project = project
        self.environment = environment
        self.test_data_loader = TestDataLoader(project)
        self.config_generator = ConfigDrivenGenerator(project)
    
    def get_urls(self, mode: str = "auto-detect", cli_mode: str = None) -> List[URLTestCase]:
        """
        Get URL test cases based on mode priority:
        1. CLI flag (highest priority)
        2. Test decorator mode
        3. Auto-detect (default)
        
        Args:
            mode: Mode from test decorator ("manual", "auto", "auto-detect")
            cli_mode: Mode from CLI flag (overrides decorator)
        
        Returns:
            List of URLTestCase objects ready for testing
        """
        effective_mode = cli_mode or mode
        
        if effective_mode == "manual":
            logger.info("ğŸ“‹ MANUAL MODE - Loading test data file")
            return self.test_data_loader.load()
        
        elif effective_mode == "auto":
            logger.info("âš™ï¸ AUTO MODE - Generating from config")
            return self.config_generator.generate()
        
        elif effective_mode == "auto-detect":
            # Check test data file first (primary)
            if self.test_data_loader.has_data_file():
                logger.info("ğŸ“‹ Test data file found - MANUAL MODE")
                return self.test_data_loader.load()
            # Fallback to config generation (secondary)
            elif self.config_generator.has_config_file():
                logger.info("âš™ï¸ Config file found - AUTO MODE")
                return self.config_generator.generate()
            else:
                raise ValueError(
                    f"âŒ No data source found for project: {self.project}\n"
                    f"   Expected either:\n"
                    f"   - Test data file: test_data/{self.project}/{self.project}_testdata.(xlsx|csv|json|yaml)\n"
                    f"   - Config file: config/url_testing/{self.project}_urls.yaml"
                )
        
        else:
            raise ValueError(f"Invalid mode: {effective_mode}. Use 'manual', 'auto', or 'auto-detect'")
```

#### 2. Test Data Loader (NEW - PRIMARY DATA SOURCE)
**Purpose**: Load test data from multiple file formats
**Responsibility**: Read Excel, CSV, JSON, YAML files and convert to URLTestCase objects

```python
class TestDataLoader:
    """
    Loads test data from multiple file formats.
    Primary data source for URL testing (MANUAL MODE).
    
    Supported Formats:
    - Excel (.xlsx) - Easy for non-technical users (QA, BA)
    - CSV (.csv) - Simple, version-controllable
    - JSON (.json) - Structured, API-friendly
    - YAML (.yaml) - Human-readable, supports comments
    """
    
    SUPPORTED_FORMATS = {
        ".xlsx": "_load_excel",
        ".csv": "_load_csv",
        ".json": "_load_json",
        ".yaml": "_load_yaml",
        ".yml": "_load_yaml",
    }
    
    def __init__(self, project: str):
        self.project = project
        self.data_dir = Path("test_data") / project
    
    def has_data_file(self) -> bool:
        """Check if any test data file exists for this project"""
        for ext in self.SUPPORTED_FORMATS:
            file_path = self.data_dir / f"{self.project}_testdata{ext}"
            if file_path.exists():
                logger.debug(f"Found test data file: {file_path}")
                return True
        return False
    
    def load(self) -> List[URLTestCase]:
        """
        Load test data from file (auto-detect format).
        Priority order: Excel > CSV > JSON > YAML
        """
        for ext, loader_method in self.SUPPORTED_FORMATS.items():
            file_path = self.data_dir / f"{self.project}_testdata{ext}"
            if file_path.exists():
                logger.info(f"ğŸ“‚ Loading test data from {file_path}")
                loader = getattr(self, loader_method)
                test_cases = loader(file_path)
                logger.info(f"âœ… Loaded {len(test_cases)} URL test cases")
                return test_cases
        
        raise FileNotFoundError(
            f"No test data file found for project: {self.project}\n"
            f"Expected file path: {self.data_dir}/{self.project}_testdata.(xlsx|csv|json|yaml)"
        )
    
    def _load_excel(self, file_path: Path) -> List[URLTestCase]:
        """Load from Excel file using pandas"""
        import pandas as pd
        df = pd.read_excel(file_path)
        return self._dataframe_to_test_cases(df)
    
    def _load_csv(self, file_path: Path) -> List[URLTestCase]:
        """Load from CSV file using pandas"""
        import pandas as pd
        df = pd.read_csv(file_path)
        return self._dataframe_to_test_cases(df)
    
    def _dataframe_to_test_cases(self, df: pd.DataFrame) -> List[URLTestCase]:
        """Convert pandas DataFrame to URLTestCase objects"""
        test_cases = []
        
        # Identify which columns are query parameters
        reserved_columns = {'workflow_id', 'environment', 'url_format', 'expected_result', 'description'}
        param_columns = [col for col in df.columns if col not in reserved_columns]
        
        for _, row in df.iterrows():
            # Extract query parameters from row
            query_params = {col: str(row[col]) for col in param_columns if pd.notna(row[col])}
            
            test_case = URLTestCase(
                workflow_id=str(row['workflow_id']),
                environment=str(row.get('environment', 'staging')),
                query_params=query_params,
                url_format=str(row.get('url_format', 'query_string')),
                expected_result=str(row.get('expected_result', 'success')),
                description=str(row.get('description', ''))
            )
            test_cases.append(test_case)
        
        return test_cases
    
    def _load_json(self, file_path: Path) -> List[URLTestCase]:
        """Load from JSON file"""
        with open(file_path) as f:
            data = json.load(f)
        
        if isinstance(data, list):
            return [URLTestCase(**item) for item in data]
        elif isinstance(data, dict) and 'test_cases' in data:
            return [URLTestCase(**item) for item in data['test_cases']]
        else:
            raise ValueError(f"Invalid JSON structure in {file_path}")
    
    def _load_yaml(self, file_path: Path) -> List[URLTestCase]:
        """Load from YAML file"""
        with open(file_path) as f:
            data = yaml.safe_load(f)
        
        if isinstance(data, list):
            return [URLTestCase(**item) for item in data]
        elif isinstance(data, dict) and 'test_cases' in data:
            return [URLTestCase(**item) for item in data['test_cases']]
        else:
            raise ValueError(f"Invalid YAML structure in {file_path}")
```

#### 3. Config-Driven Generator (EXISTING - SECONDARY/FALLBACK)
**Purpose**: Generate URL combinations when manual data not provided
**Responsibility**: Auto-generate test cases from YAML config (AUTO MODE)

```python
class ConfigDrivenGenerator:
    """
    Generate URL combinations from YAML config.
    Secondary/fallback data source when test data file not provided (AUTO MODE).
    
    Use Cases:
    - Quick exploratory testing without creating test data file
    - Testing all possible combinations (cartesian product)
    - Pairwise testing for optimization
    """
    
    def __init__(self, project: str):
        self.project = project
        self.config_dir = Path("config") / "url_testing"
    
    def has_config_file(self) -> bool:
        """Check if config file exists for this project"""
        config_file = self.config_dir / f"{self.project}_urls.yaml"
        return config_file.exists()
    
    def generate(self, strategy: str = "cartesian") -> List[URLTestCase]:
        """
        Generate URL combinations from config.
        
        Args:
            strategy: "cartesian" (all combinations) or "pairwise" (optimized)
        
        Returns:
            List of URLTestCase objects
        """
        config = self._load_config()
        
        if strategy == "cartesian":
            logger.info("ğŸ”¢ Generating cartesian product (all combinations)")
            return self._generate_cartesian(config)
        elif strategy == "pairwise":
            logger.info("ğŸ¯ Generating pairwise combinations (optimized)")
            return self._generate_pairwise(config)
        else:
            raise ValueError(f"Invalid strategy: {strategy}")
    
    def _load_config(self) -> dict:
        """Load YAML config file"""
        config_file = self.config_dir / f"{self.project}_urls.yaml"
        
        if not config_file.exists():
            raise FileNotFoundError(
                f"Config file not found: {config_file}\n"
                f"Expected path: {self.config_dir}/{self.project}_urls.yaml"
            )
        
        with open(config_file) as f:
            config = yaml.safe_load(f)
        
        return config
    
    # ... (cartesian and pairwise generation methods)
```

#### 4. URL Builder (SHARED - WORKS WITH BOTH MODES)
**Purpose**: Build final URLs regardless of data source
**Responsibility**: Apply templates, inject parameters, support multiple URL formats

```python
class URLBuilder:
    """
    Builds final URLs from URLTestCase objects.
    Works with both manual data and auto-generated combinations.
    
    Supports multiple URL formats:
    - Query string: domain.com/page?workflow_id=X&param=Y (current)
    - Path parameter: domain.com/workflow/X?param=Y (future)
    - Path-based: domain.com/X/booking?param=Y (future)
    - Hybrid: domain.com/X?param=Y (future)
    """
    
    ENVIRONMENT_URLS = {
        "staging": "https://bookslot-staging.centerforvein.com",
        "production": "https://bookslot.centerforvein.com",
    }
    
    def __init__(self, environment: str):
        self.environment = environment
        self.base_url = self.ENVIRONMENT_URLS.get(environment)
        
        if not self.base_url:
            raise ValueError(
                f"Invalid environment: {environment}. "
                f"Supported: {list(self.ENVIRONMENT_URLS.keys())}"
            )
    
    def build(self, test_case: URLTestCase) -> str:
        """
        Build URL from test case based on url_format.
        
        Args:
            test_case: URLTestCase object with workflow_id and query_params
        
        Returns:
            Complete URL ready for testing
        """
        url_format = test_case.url_format or "query_string"
        
        # Route to appropriate builder based on format
        builders = {
            "query_string": self._build_query_string,
            "path_parameter": self._build_path_parameter,
            "path_based": self._build_path_based,
            "hybrid": self._build_hybrid,
        }
        
        builder_func = builders.get(url_format, self._build_query_string)
        final_url = builder_func(test_case)
        
        logger.debug(f"Built URL: {final_url} (format: {url_format})")
        return final_url
    
    def _build_query_string(self, test_case: URLTestCase) -> str:
        """
        Build query string URL: domain.com/page?workflow_id=X&param=Y
        
        Current format for Bookslot project.
        """
        query_params = {
            "workflow_id": test_case.workflow_id,
            **test_case.query_params
        }
        query_string = "&".join(f"{k}={v}" for k, v in query_params.items())
        return f"{self.base_url}/booking?{query_string}"
    
    def _build_path_parameter(self, test_case: URLTestCase) -> str:
        """
        Build path parameter URL: domain.com/workflow/X?param=Y
        
        Future format support.
        """
        query_string = "&".join(f"{k}={v}" for k, v in test_case.query_params.items())
        return f"{self.base_url}/workflow/{test_case.workflow_id}?{query_string}"
    
    def _build_path_based(self, test_case: URLTestCase) -> str:
        """
        Build path-based URL: domain.com/X/booking?param=Y
        
        Future format support.
        """
        query_string = "&".join(f"{k}={v}" for k, v in test_case.query_params.items())
        return f"{self.base_url}/{test_case.workflow_id}/booking?{query_string}"
    
    def _build_hybrid(self, test_case: URLTestCase) -> str:
        """
        Build hybrid URL: domain.com/X?param=Y
        
        Future format support.
        """
        query_string = "&".join(f"{k}={v}" for k, v in test_case.query_params.items())
        return f"{self.base_url}/{test_case.workflow_id}?{query_string}"
```

#### 5. URL Validator (COMPREHENSIVE - LEVEL 4)
**Purpose**: Validate URLs work properly before actual testing
**Responsibility**: HTTP 200 + element presence + no errors

```python
@dataclass
class ValidationResult:
    """Result of URL validation"""
    url: str
    status: str = "PENDING"  # PENDING, PASSED, FAILED
    http_status: int = None
    http_ok: bool = False
    element_found: bool = None
    errors_found: List[str] = field(default_factory=list)
    message: str = ""
    duration_ms: int = 0


class URLValidator:
    """
    Comprehensive URL validation (LEVEL 4).
    
    Validation Steps:
    1. HTTP 200 status code check (basic connectivity)
    2. Expected element presence (page loaded correctly)
    3. No error messages on page (no application errors)
    
    All three must pass for validation to succeed.
    """
    
    def __init__(self, expected_element: str = "h1, form, [data-testid='booking-form']"):
        """
        Args:
            expected_element: CSS selector for element that should be present
        """
        self.expected_element = expected_element
    
    def validate(self, url: str, driver: WebDriver) -> ValidationResult:
        """
        Validate URL comprehensively (all 3 levels).
        
        Args:
            url: URL to validate
            driver: Selenium WebDriver instance
        
        Returns:
            ValidationResult with detailed status
        """
        result = ValidationResult(url=url)
        start_time = time.time()
        
        try:
            # LEVEL 1: HTTP 200 Status Check
            logger.debug(f"Validating URL: {url}")
            response = requests.get(url, timeout=10)
            result.http_status = response.status_code
            result.http_ok = (response.status_code == 200)
            
            if not result.http_ok:
                result.status = "FAILED"
                result.message = f"HTTP {response.status_code}"
                return result
            
            # LEVEL 2: Element Presence Check
            driver.get(url)
            try:
                element = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, self.expected_element))
                )
                result.element_found = True
                logger.debug(f"âœ… Element found: {self.expected_element}")
            except TimeoutException:
                result.element_found = False
                result.status = "FAILED"
                result.message = f"Element '{self.expected_element}' not found"
                return result
            
            # LEVEL 3: No Error Messages Check
            error_selectors = [
                "[class*='error']",
                "[class*='alert-danger']",
                "[class*='error-message']",
                "[id*='error']",
                "h1:contains('404')",
                "h1:contains('500')",
                ".error-page",
            ]
            
            errors_found = []
            for selector in error_selectors:
                try:
                    elements = driver.find_elements(By.CSS_SELECTOR, selector)
                    visible_errors = [e.text for e in elements if e.is_displayed() and e.text.strip()]
                    errors_found.extend(visible_errors)
                except:
                    continue
            
            if errors_found:
                result.errors_found = errors_found
                result.status = "FAILED"
                result.message = f"Errors found: {', '.join(errors_found[:3])}"
                logger.warning(f"âŒ Errors found on page: {errors_found}")
                return result
            
            # ALL VALIDATIONS PASSED
            result.status = "PASSED"
            result.message = "All validations passed (HTTP 200 + Element + No Errors)"
            logger.info(f"âœ… URL validation passed: {url}")
            
        except Exception as e:
            result.status = "FAILED"
            result.message = f"Validation error: {str(e)}"
            logger.error(f"âŒ Validation exception: {e}")
        
        finally:
            result.duration_ms = int((time.time() - start_time) * 1000)
        
        return result
```

#### 4. Test Runner Integration
- **Responsibility**: Pytest parametrization integration
- **Output**: Parametrized test functions

---

## ğŸ’¾ Data Structure Design (HYBRID APPROACH)

### Overview

The hybrid approach requires two types of data structures:

1. **Test Data Files** (PRIMARY): Excel/CSV/JSON/YAML files with manual test data
2. **Config Files** (SECONDARY): YAML files for auto-generation (fallback)

---

### 1. Test Data File Structures (MANUAL MODE - PRIMARY)

#### Excel/CSV File Structure

```excel
# test_data/bookslot/bookslot_testdata.xlsx

| workflow_id | environment | language | source | patient_type | insurance_verified | utm_campaign | url_format     | expected_result | description                    |
|-------------|-------------|----------|--------|--------------|-------------------|--------------|----------------|-----------------|--------------------------------|
| WF001       | staging     | en       | web    | new          | true              | summer_promo | query_string   | success         | New patient summer campaign    |
| WF002       | staging     | es       | mobile | returning    | false             | default      | query_string   | success         | Returning patient mobile       |
| WF003       | staging     | en       | tablet | vip          | true              | urgent_care  | query_string   | success         | VIP patient urgent care        |
| WF004       | staging     | fr       | web    | new          | true              | default      | query_string   | success         | French new patient             |
| WF005       | production  | en       | web    | returning    | true              | summer_promo | query_string   | success         | Production returning patient   |
| WF006       | production  | es       | referral | new        | false             | default      | query_string   | success         | Production referral new patient|
```

**Column Definitions:**
- **workflow_id** (REQUIRED): Workflow identifier
- **environment** (REQUIRED): staging or production
- **language, source, patient_type, etc.** (FLEXIBLE): Query parameters (any number)
- **url_format** (OPTIONAL): query_string, path_parameter, etc. (default: query_string)
- **expected_result** (OPTIONAL): Expected test outcome (default: success)
- **description** (OPTIONAL): Human-readable description

#### JSON File Structure

```json
// test_data/bookslot/bookslot_testdata.json

{
  "test_cases": [
    {
      "workflow_id": "WF001",
      "environment": "staging",
      "query_params": {
        "language": "en",
        "source": "web",
        "patient_type": "new",
        "insurance_verified": "true",
        "utm_campaign": "summer_promo"
      },
      "url_format": "query_string",
      "expected_result": "success",
      "description": "New patient summer campaign"
    },
    {
      "workflow_id": "WF002",
      "environment": "staging",
      "query_params": {
        "language": "es",
        "source": "mobile",
        "patient_type": "returning",
        "insurance_verified": "false",
        "utm_campaign": "default"
      },
      "url_format": "query_string",
      "expected_result": "success",
      "description": "Returning patient mobile"
    }
  ]
}
```

#### YAML File Structure

```yaml
# test_data/bookslot/bookslot_testdata.yaml

test_cases:
  - workflow_id: WF001
    environment: staging
    query_params:
      language: en
      source: web
      patient_type: new
      insurance_verified: true
      utm_campaign: summer_promo
    url_format: query_string
    expected_result: success
    description: "New patient summer campaign"
    
  - workflow_id: WF002
    environment: staging
    query_params:
      language: es
      source: mobile
      patient_type: returning
      insurance_verified: false
      utm_campaign: default
    url_format: query_string
    expected_result: success
    description: "Returning patient mobile"
```

**Advantages by Format:**
- **Excel**: Easy for QA/BA to create and maintain, no technical knowledge needed
- **CSV**: Simple, version-controllable, works with Git
- **JSON**: Structured, API-friendly, easy to parse
- **YAML**: Human-readable, supports comments, config-style

---

### 2. Configuration File Structure (AUTO MODE - SECONDARY/FALLBACK)

```yaml
# config/url_testing/bookslot_urls.yaml

project: bookslot
version: "2.0"
description: "URL auto-generation configuration for Bookslot project (fallback mode)"

environments:
  staging:
    base_url: "https://bookslot-staging.centerforvein.com"
    
    # Workflow IDs (up to 6)
    workflow_ids:
      - id: "WF_STAGE_001"
        name: "New Patient Consultation"
        description: "Standard new patient workflow"
        
      - id: "WF_STAGE_002"
        name: "Follow-up Appointment"
        
      - id: "WF_STAGE_003"
        name: "Emergency Consultation"
        
      - id: "WF_STAGE_004"
        name: "Video Consultation"
        
      - id: "WF_STAGE_005"
        name: "Lab Results Review"
        
      - id: "WF_STAGE_006"
        name: "Prescription Renewal"
    
    # Query Parameters (flexible count)
    query_parameters:
      language:
        values: ["en", "es", "fr"]
        required: false
        description: "User interface language"
        
      source:
        values: ["web", "mobile", "tablet", "referral"]
        required: false
        description: "Traffic source"
        
      utm_campaign:
        values: ["summer_promo", "default", "urgent_care"]
        required: false
        
      patient_type:
        values: ["new", "returning", "vip"]
        required: true
        description: "Patient classification"
        
      insurance_verified:
        values: ["true", "false"]
        required: false
        
      appointment_priority:
        values: ["normal", "urgent", "emergency"]
        required: false
  
  production:
    base_url: "https://bookslot.centerforvein.com"
    
    workflow_ids:
      - id: "PROD_WF_001"
        name: "New Patient Consultation"
        
      - id: "PROD_WF_002"
        name: "Follow-up Appointment"
        
      - id: "PROD_WF_003"
        name: "Emergency Consultation"
        
      - id: "PROD_WF_004"
        name: "Video Consultation"
        
      - id: "PROD_WF_005"
        name: "Lab Results Review"
        
      - id: "PROD_WF_006"
        name: "Prescription Renewal"
    
    query_parameters:
      language:
        values: ["en", "es"]
        required: false
        
      source:
        values: ["web", "mobile", "referral"]
        required: false
        
      patient_type:
        values: ["new", "returning"]
        required: true

# Combination Rules (for AUTO mode only)
combination_rules:
  # All combinations by default
  strategy: "cartesian_product"
  
  # Optional: Limit combinations
  max_combinations: 1000
  
  # Optional: Parameter dependencies (FUTURE)
  dependencies:
    - if:
        parameter: "appointment_priority"
        value: "emergency"
      then:
        parameter: "source"
        must_be: "web"
        
  # Optional: Exclusions (FUTURE)
  exclusions:
    - parameters: ["utm_campaign=default", "patient_type=vip"]
      reason: "VIP patients never use default campaign"

# Test Configuration
test_config:
  parallel: true
  max_workers: 4
  timeout_per_url: 30
  retry_failed: true
  retry_count: 2
```

---

### 3. Python Data Models (HYBRID - UNIFIED)

```python
# framework/core/url_testing/models.py

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
from enum import Enum
from pathlib import Path

class URLFormat(str, Enum):
    """Supported URL formats"""
    QUERY_STRING = "query_string"        # domain.com/page?workflow_id=X&param=Y
    PATH_PARAMETER = "path_parameter"    # domain.com/workflow/X?param=Y
    PATH_BASED = "path_based"            # domain.com/X/booking?param=Y
    HYBRID = "hybrid"                    # domain.com/X?param=Y


class DataSource(str, Enum):
    """Data source types"""
    MANUAL = "manual"      # Test data from files
    AUTO = "auto"          # Generated from config
    AUTO_DETECT = "auto-detect"  # Detect automatically


@dataclass
class URLTestCase:
    """
    Unified test case model.
    Works with both manual data and auto-generated combinations.
    """
    workflow_id: str
    environment: str = "staging"
    query_params: Dict[str, Any] = field(default_factory=dict)
    url_format: str = "query_string"
    expected_result: str = "success"
    description: str = ""
    
    # Metadata (auto-populated)
    data_source: str = DataSource.MANUAL  # manual or auto
    test_id: Optional[str] = None
    final_url: Optional[str] = None
    
    def __post_init__(self):
        """Generate test ID if not provided"""
        if not self.test_id:
            params_str = "_".join(f"{k}={v}" for k, v in list(self.query_params.items())[:3])
            self.test_id = f"{self.workflow_id}_{self.environment}_{params_str}"[:80]


@dataclass
class ValidationResult:
    """Result of URL validation"""
    url: str
    status: str = "PENDING"  # PENDING, PASSED, FAILED
    http_status: Optional[int] = None
    http_ok: bool = False
    element_found: Optional[bool] = None
    errors_found: List[str] = field(default_factory=list)
    message: str = ""
    duration_ms: int = 0
    
    def is_valid(self) -> bool:
        """Check if validation passed"""
        return self.status == "PASSED"


# FOR CONFIG-DRIVEN GENERATION (AUTO MODE) #

class CombinationStrategy(str, Enum):
    CARTESIAN_PRODUCT = "cartesian_product"
    PAIRWISE = "pairwise"
    CUSTOM = "custom"


@dataclass
class WorkflowID:
    """Represents a workflow ID configuration"""
    id: str
    name: str
    description: Optional[str] = None
    enabled: bool = True
    
    
@dataclass
class QueryParameter:
    """Represents a query parameter configuration"""
    name: str
    values: List[str]
    required: bool = False
    description: Optional[str] = None
    default_value: Optional[str] = None
    
    
@dataclass
class ParameterDependency:
    """Defines dependency between parameters (FUTURE)"""
    if_parameter: str
    if_value: str
    then_parameter: str
    then_must_be: str
    
    
@dataclass
class ParameterExclusion:
    """Defines parameter combinations to exclude (FUTURE)"""
    parameters: List[str]  # e.g., ["param1=value1", "param2=value2"]
    reason: str
    
    
@dataclass
class EnvironmentConfig:
    """Environment-specific URL configuration (for AUTO mode)"""
    name: str
    base_url: str
    workflow_ids: List[WorkflowID]
    query_parameters: Dict[str, QueryParameter]
    
    
@dataclass
class CombinationRules:
    """Rules for generating URL combinations (for AUTO mode)"""
    strategy: CombinationStrategy = CombinationStrategy.CARTESIAN_PRODUCT
    max_combinations: Optional[int] = None
    dependencies: List[ParameterDependency] = field(default_factory=list)
    exclusions: List[ParameterExclusion] = field(default_factory=list)
    
    
@dataclass
class URLTestConfig:
    """Complete URL testing configuration (for AUTO mode)"""
    project: str
    version: str
    description: str
    environments: Dict[str, EnvironmentConfig]
    combination_rules: CombinationRules
    test_config: Dict[str, Any]


@dataclass
class URLTestResult:
    """Result of a single URL test"""
    test_case: URLTestCase
    validation_result: ValidationResult
    test_passed: bool
    error_message: Optional[str] = None
    screenshot_path: Optional[Path] = None
    duration_ms: int = 0
```

---

### 4. Data Flow (HYBRID ARCHITECTURE)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MANUAL MODE (PRIMARY)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  Excel/CSV/JSON/YAML File                                 â”‚
â”‚        â†“                                                   â”‚
â”‚  TestDataLoader.load()                                     â”‚
â”‚        â†“                                                   â”‚
â”‚  List[URLTestCase]                                         â”‚
â”‚        â†“                                                   â”‚
â”‚  URLBuilder.build()                                        â”‚
â”‚        â†“                                                   â”‚
â”‚  Final URLs with metadata                                  â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 AUTO MODE (SECONDARY/FALLBACK)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  YAML Config File                                          â”‚
â”‚        â†“                                                   â”‚
â”‚  ConfigDrivenGenerator.generate()                          â”‚
â”‚        â†“                                                   â”‚
â”‚  Cartesian Product / Pairwise                              â”‚
â”‚        â†“                                                   â”‚
â”‚  List[URLTestCase]                                         â”‚
â”‚        â†“                                                   â”‚
â”‚  URLBuilder.build()                                        â”‚
â”‚        â†“                                                   â”‚
â”‚  Final URLs with metadata                                  â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Python Data Models
    workflow_id: str
    workflow_name: str
    query_params: Dict[str, str]
    test_id: str  # Unique identifier for reporting
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return f"{self.test_id}: {self.url}"
```

---

## ğŸ”§ Implementation Approaches

### Approach 1: Simple Nested Loops (âŒ Not Recommended)

```python
# Anti-pattern: Hardcoded, not scalable

workflow_ids = ["WF001", "WF002", "WF003"]
languages = ["en", "es"]
sources = ["web", "mobile"]

urls = []
for wf in workflow_ids:
    for lang in languages:
        for source in sources:
            url = f"{base_url}?workflow_id={wf}&lang={lang}&source={source}"
            urls.append(url)

# Problems:
# - Hardcoded values
# - Not environment-aware
# - Not reusable
# - Hard to maintain
# - No validation
```

### Approach 2: Pytest Parametrize with Lists (âš ï¸ Limited)

```python
# Better but still limited

import pytest

@pytest.mark.parametrize("workflow_id", ["WF001", "WF002", "WF003"])
@pytest.mark.parametrize("language", ["en", "es"])
@pytest.mark.parametrize("source", ["web", "mobile"])
def test_bookslot_workflows(workflow_id, language, source, base_url):
    url = f"{base_url}?workflow_id={workflow_id}&lang={language}&source={source}"
    # Test logic here
    
# Problems:
# - Still hardcoded
# - Not environment-aware
# - Difficult to manage 6+ workflow IDs and 4+ params
# - No dependency handling
```

### Approach 3: Factory Pattern with Config (âœ… Good)

```python
# Modern, scalable approach

from framework.core.url_testing import URLFactory, URLConfigManager

# Load configuration
config = URLConfigManager.load_config("bookslot", environment="staging")

# Generate URLs
factory = URLFactory(config)
urls = factory.generate_all_combinations()

# Use with pytest
@pytest.mark.parametrize("url_obj", urls, ids=lambda u: u.test_id)
def test_bookslot_workflow(url_obj: GeneratedURL, page):
    page.goto(url_obj.url)
    # Test logic here
    
# Benefits:
# âœ… Configuration-driven
# âœ… Environment-aware
# âœ… Reusable
# âœ… Maintainable
# âœ… Supports dependencies and exclusions
```

### Approach 4: Builder Pattern (âœ… Best for Complex Cases)

```python
# Ultimate flexibility

from framework.core.url_testing import URLBuilder

# Fluent API for building URLs
urls = (URLBuilder(project="bookslot", environment="staging")
        .with_workflow_ids(["WF001", "WF002"])
        .with_parameter("language", ["en", "es"])
        .with_parameter("source", ["web", "mobile"])
        .with_dependency("priority=emergency", must_have="source=web")
        .exclude_combination(["language=fr", "source=mobile"])
        .build())

# Benefits:
# âœ… Fluent, readable API
# âœ… Highly flexible
# âœ… Can override config dynamically
# âœ… Easy to understand intent
```

---

## ğŸ† Recommended Solution

### **Hybrid Approach: Config-Driven Factory + Builder Pattern**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RECOMMENDED ARCHITECTURE                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  1. YAML Config (Primary Source of Truth)                 â”‚
â”‚     â””â”€> config/url_configs/bookslot_urls.yaml             â”‚
â”‚                                                            â”‚
â”‚  2. URLConfigManager (Loads & Validates Config)           â”‚
â”‚     â””â”€> Parses YAML, validates structure                  â”‚
â”‚                                                            â”‚
â”‚  3. URLFactory (Generates Combinations)                    â”‚
â”‚     â””â”€> Uses itertools for cartesian products             â”‚
â”‚     â””â”€> Applies rules, dependencies, exclusions           â”‚
â”‚                                                            â”‚
â”‚  4. URLBuilder (Optional Override)                         â”‚
â”‚     â””â”€> For one-off tests or dynamic cases                â”‚
â”‚                                                            â”‚
â”‚  5. Pytest Integration                                     â”‚
â”‚     â””â”€> @pytest.mark.parametrize with generated URLs      â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why This Approach?

1. **Configuration-Driven**: Easy to modify without code changes
2. **Environment-Aware**: Automatic environment switching
3. **Reusable**: Works for any project (not just Bookslot)
4. **Scalable**: Handles 6 workflow IDs Ã— 4+ params = 1000+ combinations
5. **Maintainable**: Clear separation of data and logic
6. **Testable**: Each component can be unit tested
7. **Modern**: Follows industry best practices

---

## ğŸ“ Configuration Examples

### Example 1: Simple Bookslot Config

```yaml
# config/url_configs/bookslot_simple.yaml

project: bookslot
environments:
  staging:
    base_url: "https://bookslot-staging.centerforvein.com"
    workflow_ids:
      - id: "WF001"
        name: "New Patient"
      - id: "WF002"
        name: "Follow-up"
    query_parameters:
      language:
        values: ["en", "es"]
      source:
        values: ["web", "mobile"]

combination_rules:
  strategy: "cartesian_product"
  
# This generates 2 workflows Ã— 2 languages Ã— 2 sources = 8 URLs
```

### Example 2: Advanced with Dependencies

```yaml
# config/url_configs/bookslot_advanced.yaml

project: bookslot
environments:
  staging:
    base_url: "https://bookslot-staging.centerforvein.com"
    workflow_ids:
      - id: "WF001"
      - id: "WF002"
      - id: "WF003"
    query_parameters:
      priority:
        values: ["normal", "urgent", "emergency"]
      source:
        values: ["web", "mobile", "phone"]
      insurance:
        values: ["verified", "pending"]

combination_rules:
  strategy: "cartesian_product"
  dependencies:
    # Emergency priority must come from web
    - if:
        parameter: "priority"
        value: "emergency"
      then:
        parameter: "source"
        must_be: "web"
  exclusions:
    # Mobile users can't have pending insurance
    - parameters: ["source=mobile", "insurance=pending"]
      reason: "Mobile app requires verified insurance"
```

---

## ğŸ® Usage Patterns

### Pattern 1: Basic Test with Config

```python
# tests/bookslot/test_all_workflow_combinations.py

import pytest
from framework.core.url_testing import URLFactory, URLConfigManager

# Load config once per module
@pytest.fixture(scope="module")
def url_combinations(environment):
    config = URLConfigManager.load_config("bookslot", environment=environment)
    factory = URLFactory(config)
    return factory.generate_all_combinations()

# Parametrize test with all URLs
@pytest.mark.parametrize("url_obj", 
    pytest.lazy_fixture("url_combinations"),
    ids=lambda u: u.test_id)
def test_workflow_loads(url_obj, page):
    """Test that all workflow URLs load successfully"""
    page.goto(url_obj.url)
    assert page.is_visible("h1")  # Basic validation
    
# Run: pytest tests/bookslot/test_all_workflow_combinations.py --env=staging
# Result: Tests 2 workflows Ã— 2 languages Ã— 2 sources = 8 tests
```

### Pattern 2: Filtered Tests

```python
# tests/bookslot/test_emergency_workflows.py

@pytest.fixture(scope="module")
def emergency_urls(environment):
    config = URLConfigManager.load_config("bookslot", environment=environment)
    factory = URLFactory(config)
    
    # Filter for emergency priority only
    all_urls = factory.generate_all_combinations()
    return [u for u in all_urls if u.query_params.get("priority") == "emergency"]

@pytest.mark.parametrize("url_obj", 
    pytest.lazy_fixture("emergency_urls"),
    ids=lambda u: u.test_id)
def test_emergency_workflow_response_time(url_obj, page):
    """Emergency workflows must load under 2 seconds"""
    import time
    start = time.time()
    page.goto(url_obj.url)
    load_time = time.time() - start
    assert load_time < 2.0, f"Emergency workflow too slow: {load_time}s"
```

### Pattern 3: Dynamic URL Building

```python
# tests/bookslot/test_custom_scenarios.py

from framework.core.url_testing import URLBuilder

def test_vip_patient_fast_track(page, environment):
    """VIP patients with verified insurance get fast-track workflow"""
    
    # Build custom URL on the fly
    url = (URLBuilder(project="bookslot", environment=environment)
           .with_workflow_id("WF_VIP_001")
           .with_parameter("patient_type", "vip")
           .with_parameter("insurance", "verified")
           .with_parameter("fast_track", "true")
           .build_single())
    
    page.goto(url.url)
    assert page.is_visible("text=Fast Track")
```

### Pattern 4: Data-Driven from External Source

```python
# tests/bookslot/test_from_excel.py

import pandas as pd
from framework.core.url_testing import URLBuilder

def test_workflows_from_excel(page, environment):
    """Load workflow combinations from Excel spreadsheet"""
    
    # Read test data from Excel
    df = pd.read_excel("test_data/bookslot_workflows.xlsx")
    
    for _, row in df.iterrows():
        url = (URLBuilder(project="bookslot", environment=environment)
               .with_workflow_id(row['workflow_id'])
               .with_parameters(row['query_params'])  # Dict from Excel
               .build_single())
        
        page.goto(url.url)
        # Test logic here
```

---

## ğŸš€ Scalability & Extensibility

### Multi-Project Support

```yaml
# config/url_configs/project_registry.yaml

projects:
  bookslot:
    config_file: "bookslot_urls.yaml"
    enabled: true
    
  ecommerce:
    config_file: "ecommerce_urls.yaml"
    enabled: true
    
  api_testing:
    config_file: "api_endpoints.yaml"
    enabled: true
```

### Plugin Architecture

```python
# framework/core/url_testing/plugins/

class URLGeneratorPlugin:
    """Base class for custom URL generation strategies"""
    
    def generate(self, config: URLTestConfig) -> List[GeneratedURL]:
        raise NotImplementedError

class CartesianProductPlugin(URLGeneratorPlugin):
    """Standard cartesian product generation"""
    pass

class PairwisePlugin(URLGeneratorPlugin):
    """Pairwise testing for reduced combinations"""
    pass

class CustomBookslotPlugin(URLGeneratorPlugin):
    """Bookslot-specific generation logic"""
    pass
```

---

## ğŸ”„ Migration Path

### Phase 1: Setup (Week 1)

1. Create configuration directory structure
2. Implement data models
3. Implement URLConfigManager
4. Write unit tests

### Phase 2: Core Implementation (Week 2)

1. Implement URLFactory with cartesian product
2. Implement URLBuilder with fluent API
3. Add dependency and exclusion logic
4. Write integration tests

### Phase 3: Pytest Integration (Week 3)

1. Create pytest fixtures
2. Implement parametrization helpers
3. Add test ID generation
4. Configure reporting

### Phase 4: Bookslot Migration (Week 4)

1. Create bookslot_urls.yaml configuration
2. Migrate existing tests to new pattern
3. Validate all combinations
4. Performance optimization

### Phase 5: Documentation & Training (Week 5)

1. Write user guide
2. Create example tests
3. Train team on new system
4. Gather feedback

---

## ğŸ“ˆ Expected Benefits

### Quantitative Benefits

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| **Configuration Time** | 2 hours | 15 minutes | 87% faster |
| **Test Coverage** | 50 combinations | 1000+ combinations | 20x more |
| **Maintenance Time** | 4 hours/month | 30 minutes/month | 87% reduction |
| **New Project Setup** | 3 days | 2 hours | 90% faster |
| **Code Duplication** | High | None | 100% reduction |

### Qualitative Benefits

- âœ… **Environment-Aware**: Automatic switching between staging/production
- âœ… **Maintainable**: Update YAML, not code
- âœ… **Reusable**: Works for future projects
- âœ… **Scalable**: Handles 1000+ URL combinations
- âœ… **Clear Reporting**: Test IDs show exactly what was tested
- âœ… **Team Productivity**: Less time configuring, more time testing

---

## ğŸ¯ Success Criteria

### Definition of Done

1. âœ… Configuration system supports YAML/JSON
2. âœ… URLFactory generates all combinations correctly
3. âœ… Dependency and exclusion rules work
4. âœ… Pytest integration complete
5. âœ… Bookslot has 100+ URL combinations tested
6. âœ… Documentation complete
7. âœ… Team trained on new system
8. âœ… 90% or more test coverage

### Acceptance Tests

1. Generate 1000 URL combinations in < 1 second
2. All URLs are valid and accessible
3. Dependencies are enforced correctly
4. Exclusions filter out invalid combinations
5. Pytest reports show clear test identifiers
6. New project can be added in < 2 hours

---

## ğŸ“š References

### Design Patterns Used

- **Factory Pattern**: URL generation
- **Builder Pattern**: Fluent URL construction
- **Strategy Pattern**: Different combination strategies
- **Repository Pattern**: Configuration management

### Industry Standards

- **Pairwise Testing**: Reduce combinations intelligently
- **Data-Driven Testing**: Separate data from logic
- **Configuration Management**: YAML-based configs
- **Test Parameterization**: Pytest fixtures

### Similar Implementations

- Cypress environment configurations
- Playwright test data management
- REST Assured API testing patterns
- Postman collection variables

---

## ğŸ¤” Decision Points for Discussion

### Questions to Consider

1. **Combination Strategy**:
   - Use full cartesian product (all combinations)?
   - Or pairwise testing (reduced, intelligent combinations)?
   - **Recommendation**: Start with cartesian, add pairwise later

2. **Configuration Format**:
   - YAML (human-readable) or JSON (strict parsing)?
   - **Recommendation**: YAML for ease of use

3. **Storage Location**:
   - Version control (Git) or external database?
   - **Recommendation**: Git for version control

4. **Performance**:
   - Generate URLs at test time or pre-generate?
   - **Recommendation**: Pre-generate for speed

5. **Reporting**:
   - How detailed should test IDs be?
   - **Recommendation**: Include workflow_id and key params

---

## ğŸ” GAP ANALYSIS: Original vs Revised Design

### Overview

This section compares the **ORIGINAL DESIGN** (config-driven, auto-generation primary) with the **REVISED DESIGN** (data-driven hybrid, manual test data primary).

---

### ğŸ“‹ Key Differences

| Aspect | Original Design (Config-Driven) | Revised Design (Data-Driven Hybrid) |
|--------|--------------------------------|-------------------------------------|
| **Primary Data Source** | YAML config file | Test data files (Excel/CSV/JSON/YAML) |
| **Secondary Data Source** | None | YAML config (fallback) |
| **URL Generation** | Auto-generate all combinations | Use provided data, generate only if needed |
| **Environments** | 3+ (Staging, QA, Production) | 2 (Staging, Production only) |
| **Workflow IDs** | In config file | In test data or config file |
| **Query Parameters** | In config, auto-combined | In test data or config file |
| **Test Data Control** | Dev team via config | QA team via Excel/CSV |
| **Mode Selection** | Single mode (auto) | Multiple modes (manual, auto, auto-detect) |
| **URL Formats** | Query string only | Query string + path-based (future-proof) |
| **Validation** | Basic (HTTP 200) | Comprehensive (HTTP 200 + element + no errors) |
| **Flexibility** | Limited to config | High (supports multiple data formats) |

---

### ğŸ—ï¸ Architectural Changes

#### Original Architecture (Config-Driven)

```
YAML Config File â†’ Config Manager â†’ URL Factory â†’ Generate All Combinations â†’ Pytest
```

**Characteristics:**
- Single data source (YAML config)
- Single flow (generate combinations)
- Dev-centric (code/config changes needed for new tests)
- Fixed combination strategy

#### Revised Architecture (Hybrid)

```
Test Data Files (Excel/CSV/JSON/YAML) â”€â”€â”
                                        â”œâ†’ URL Data Manager â†’ URL Builder â†’ Pytest
YAML Config (fallback) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Characteristics:**
- Dual data sources (test data files + config)
- Multiple flows (manual + auto)
- QA-centric (non-developers can add tests via Excel)
- Flexible mode selection

---

### ğŸ†• New Components Required

| Component | Purpose | Priority | Effort |
|-----------|---------|----------|--------|
| **URL Data Manager** | Route between manual/auto modes | ğŸ”´ CRITICAL | 2 days |
| **Test Data Loader** | Load Excel/CSV/JSON/YAML files | ğŸ”´ CRITICAL | 3 days |
| **Mode Detection Logic** | Auto-detect data source | ğŸ”´ CRITICAL | 1 day |
| **Multi-Format Parser** | Support 4 file formats | ğŸŸ¡ HIGH | 2 days |
| **Comprehensive Validator** | HTTP 200 + element + errors | ğŸŸ¡ HIGH | 2 days |
| **URL Format Templates** | Support multiple URL patterns | ğŸŸ¢ MEDIUM | 2 days |
| **CLI Mode Flag** | --mode=manual/auto | ğŸŸ¢ MEDIUM | 1 day |
| **Test Decorator** | @pytest.mark.url_mode() | ğŸŸ¢ MEDIUM | 1 day |

**Total Estimated Effort**: **14 days** (2.8 weeks)

---

### ğŸ“ Modified Components

| Component | Original Responsibility | New Responsibility | Changes Needed |
|-----------|------------------------|-------------------|----------------|
| **URL Builder** | Build from config | Build from test data OR config | Add test data support |
| **Data Models** | Config-only models | Unified models (test data + config) | Add URLTestCase model |
| **Test Fixtures** | Load config | Detect mode, load appropriate source | Add mode detection |
| **Pytest Parametrization** | From config | From test data OR config | Add data loader |

---

### ğŸ“Š Feature Comparison Matrix

| Feature | Original Design | Revised Design | Impact |
|---------|----------------|----------------|--------|
| **Test Data Entry** | Developers only (YAML editing) | QA team (Excel), Developers (YAML) | âœ… Democratized |
| **Data Formats Supported** | 1 (YAML) | 4 (Excel, CSV, JSON, YAML) | âœ… More flexible |
| **Mode Selection** | Fixed (auto) | 3 options (manual, auto, auto-detect) | âœ… More control |
| **Combination Strategy** | Always generate | Load data OR generate | âœ… Efficient |
| **URL Formats** | Query string only | Query string + path-based + more | âœ… Future-proof |
| **Validation Level** | Basic (HTTP 200) | Comprehensive (3-level) | âœ… More thorough |
| **Environment Count** | 3+ | 2 (Staging, Production) | âš ï¸ Simplified |
| **Dependency Rules** | Supported | Optional (future) | â¸ï¸ Deferred |
| **Exclusion Rules** | Supported | Optional (future) | â¸ï¸ Deferred |
| **Pairwise Testing** | Supported | Optional (future) | â¸ï¸ Deferred |

---

### âœ… Requirements Met (Updated Based on User Feedback)

#### âœ… FULLY MET

1. **FR-1: Environment-Specific Configurations** âœ…
   - Original: 3+ environments
   - Revised: 2 environments (staging, production)
   - **Status**: SIMPLIFIED per user feedback

2. **FR-2: Dynamic Workflow ID Injection** âœ…
   - Original: From config file
   - Revised: From test data file (primary) or config (fallback)
   - **Status**: ENHANCED with dual source support

3. **FR-3: Multiple Query Parameters** âœ…
   - Original: From config file, auto-combined
   - Revised: From test data file (provided) or config (generated)
   - **Status**: ENHANCED with manual control

4. **FR-4: Hybrid Mode - Manual + Auto Generation** âœ…
   - Original: Auto-generation only
   - Revised: Manual test data (primary) + Auto-generation (fallback)
   - **Status**: NEW FEATURE, fully implemented

7. **FR-7: URL Validation Before Testing** âœ…
   - Original: Basic HTTP check
   - Revised: Comprehensive (HTTP 200 + element + no errors)
   - **Status**: ENHANCED (Level 4 validation)

8. **FR-8: Flexible URL Templates** âœ…
   - Original: Query string only
   - Revised: Query string + path-based + hybrid + path-parameter
   - **Status**: ENHANCED with multiple format support

#### â¸ï¸ OPTIONAL (Future Implementation)

5. **FR-5: Parameter Dependencies** â¸ï¸
   - Original: Supported in config
   - Revised: Optional, designed with hooks for future implementation
   - **Status**: NOT NEEDED NOW (per user feedback)

6. **FR-6: Parameter Exclusions** â¸ï¸
   - Original: Supported in config
   - Revised: Optional, designed with extensibility for future needs
   - **Status**: NOT NEEDED NOW (per user feedback)

---

### ğŸš§ Implementation Impact

#### Components to Build (New)

1. **URL Data Manager (NEW)** - 2 days
   - Mode detection logic
   - Router between manual/auto sources
   - CLI flag support
   - Test decorator support

2. **Test Data Loader (NEW)** - 3 days
   - Excel parser (pandas)
   - CSV parser (pandas)
   - JSON parser (json)
   - YAML parser (yaml)
   - Auto-format detection

3. **Comprehensive Validator (NEW)** - 2 days
   - HTTP status validation
   - Element presence validation
   - Error message detection
   - Validation result model

#### Components to Modify (Existing)

1. **URL Builder** - 1 day
   - Accept URLTestCase objects
   - Support multiple URL formats
   - Environment URL mapping

2. **Test Fixtures** - 1 day
   - Add mode selection
   - Integrate URL Data Manager
   - Support both manual and auto modes

3. **Data Models** - 1 day
   - Add URLTestCase model
   - Add ValidationResult model
   - Add DataSource enum

#### Total Implementation Time

```
NEW COMPONENTS:      7 days
MODIFIED COMPONENTS: 3 days
TESTING & QA:        2 days
DOCUMENTATION:       1 day
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL:              13 days (2.6 weeks)
```

---

### ğŸ’¡ Migration Path

#### For Existing Tests

**OPTION 1: Gradual Migration (Recommended)**
- Week 1: Implement hybrid system (both modes work)
- Week 2: Create test data files for critical tests
- Week 3: Migrate remaining tests
- Week 4: Deprecate config-only mode (optional)

**OPTION 2: Big Bang Migration**
- Convert all config to test data files upfront
- Single switchover
- Higher risk, faster completion

**OPTION 3: Coexistence**
- Keep both approaches forever
- Some tests use manual data, others use auto-generation
- Maximum flexibility, slight complexity overhead

#### Recommended Approach: **Option 1 (Gradual Migration)**

Allows teams to adapt, test both approaches, and choose what works best per test scenario.

---

### ğŸ“ˆ Expected Benefits

#### Quantitative Benefits

| Metric | Original Design | Revised Design | Improvement |
|--------|----------------|----------------|-------------|
| **Test Data Creation Time** | 15 min (YAML editing) | 2 min (Excel row) | **87% faster** |
| **People Who Can Add Tests** | 2 (devs with YAML knowledge) | 10+ (entire QA team) | **5x more** |
| **Data Formats Supported** | 1 (YAML) | 4 (Excel/CSV/JSON/YAML) | **4x more** |
| **Mode Flexibility** | 1 (auto only) | 3 (manual/auto/detect) | **3x more** |
| **URL Format Support** | 1 (query string) | 4+ (extensible) | **4x more** |
| **Validation Thoroughness** | 33% (HTTP only) | 100% (HTTP+element+errors) | **3x better** |

#### Qualitative Benefits

âœ… **Democratization**: Non-developers can create tests  
âœ… **Flexibility**: Support manual and auto modes  
âœ… **Future-Proof**: Extensible to new URL formats  
âœ… **Quality**: Comprehensive validation catches more issues  
âœ… **Efficiency**: Use manual data when available, generate when needed  
âœ… **Maintainability**: Test data easier to update (Excel vs YAML)  
âœ… **Version Control**: CSV/YAML easier to diff in Git than Excel  
âœ… **Scalability**: Supports projects with 100s of combinations  

---

### ğŸ¯ Recommendation

**APPROVE REVISED DESIGN (Data-Driven Hybrid)**

**Reasons:**
1. Meets all user-specified requirements
2. More flexible and future-proof
3. Democratizes test creation (QA team can contribute)
4. Supports multiple data formats
5. Only 2.6 weeks implementation time
6. Low risk (hybrid approach maintains backward compatibility)
7. High ROI (87% faster test data creation)

**Risk Mitigation:**
- Implement gradual migration (Option 1)
- Keep both modes working (no breaking changes)
- Provide clear documentation and examples
- Train QA team on Excel-based test data creation

---

## ğŸ¬ Next Steps

### Phase 1: Design Approval (Week 1)

**Tasks:**
1. âœ… Review revised design document with team
2. â³ Get feedback on hybrid approach (manual + auto)
3. â³ Confirm test data file formats (Excel priority?)
4. â³ Approve architecture and components
5. â³ Sign-off from stakeholders

**Deliverables:**
- Approved design document
- Confirmed requirements
- Go-ahead for implementation

---

### Phase 2: Core Implementation (Week 2-3)

#### Week 2: Foundation
**Priority 1: Data Models (2 days)**
- [ ] Create `URLTestCase` dataclass
- [ ] Create `ValidationResult` dataclass
- [ ] Create `DataSource` enum
- [ ] Unit tests for models

**Priority 2: Test Data Loader (3 days)**
- [ ] Implement Excel loader (pandas)
- [ ] Implement CSV loader (pandas)
- [ ] Implement JSON loader
- [ ] Implement YAML loader
- [ ] Auto-format detection
- [ ] Unit tests for each loader

#### Week 3: Core Components
**Priority 3: URL Data Manager (2 days)**
- [ ] Implement mode detection logic
- [ ] Implement routing (manual vs auto)
- [ ] CLI flag support (`--mode=manual/auto`)
- [ ] Test decorator support
- [ ] Integration tests

**Priority 4: URL Builder (1 day)**
- [ ] Support URLTestCase objects
- [ ] Support multiple URL formats
- [ ] Environment URL mapping
- [ ] Unit tests

**Priority 5: URL Validator (2 days)**
- [ ] HTTP 200 check
- [ ] Element presence check
- [ ] Error message detection
- [ ] Comprehensive validation
- [ ] Unit tests

---

### Phase 3: Integration (Week 4)

**Priority 6: Pytest Integration (3 days)**
- [ ] Create pytest fixtures
- [ ] Update existing fixtures
- [ ] Add CLI flags
- [ ] Add test decorators
- [ ] Test with Bookslot project

**Priority 7: Config-Driven Generator (2 days)** *(Fallback Mode)*
- [ ] Implement cartesian product generation
- [ ] Implement pairwise generation (optional)
- [ ] Load from YAML config
- [ ] Integration with URL Data Manager

---

### Phase 4: Testing & Polish (Week 5)

**Priority 8: Testing (2 days)**
- [ ] End-to-end testing with Bookslot project
- [ ] Test manual mode (Excel/CSV/JSON/YAML)
- [ ] Test auto mode (config generation)
- [ ] Test auto-detect mode
- [ ] Test all URL formats
- [ ] Test comprehensive validation

**Priority 9: Documentation (2 days)**
- [ ] User guide for QA team (Excel-based)
- [ ] Developer guide (YAML config)
- [ ] Code documentation
- [ ] Example test data files
- [ ] Example tests

**Priority 10: Training (1 day)**
- [ ] Train QA team on Excel test data creation
- [ ] Train developers on config-driven approach
- [ ] Demo session
- [ ] Q&A

---

### Implementation Timeline (5 Weeks)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   IMPLEMENTATION ROADMAP                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  WEEK 1: Design Approval & Sign-off                            â”‚
â”‚    â””â”€â†’ Review, feedback, approval                              â”‚
â”‚                                                                 â”‚
â”‚  WEEK 2: Foundation                                             â”‚
â”‚    â”œâ”€â†’ Data models (URLTestCase, ValidationResult)             â”‚
â”‚    â””â”€â†’ Test Data Loader (Excel/CSV/JSON/YAML)                  â”‚
â”‚                                                                 â”‚
â”‚  WEEK 3: Core Components                                        â”‚
â”‚    â”œâ”€â†’ URL Data Manager (mode detection, routing)              â”‚
â”‚    â”œâ”€â†’ URL Builder (multi-format support)                      â”‚
â”‚    â””â”€â†’ URL Validator (comprehensive validation)                â”‚
â”‚                                                                 â”‚
â”‚  WEEK 4: Integration                                            â”‚
â”‚    â”œâ”€â†’ Pytest integration (fixtures, CLI flags)                â”‚
â”‚    â””â”€â†’ Config-Driven Generator (fallback mode)                 â”‚
â”‚                                                                 â”‚
â”‚  WEEK 5: Testing & Polish                                       â”‚
â”‚    â”œâ”€â†’ End-to-end testing with Bookslot                        â”‚
â”‚    â”œâ”€â†’ Documentation (user guide, dev guide)                   â”‚
â”‚    â””â”€â†’ Training (QA team, developers)                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Estimated Total Time: 5 weeks (25 working days)
Estimated Effort: 13-14 developer days (actual coding)
```

---

### Immediate Actions (This Week)

#### For Team Lead
1. Review this design document thoroughly
2. Schedule design review meeting with stakeholders
3. Identify any concerns or questions
4. Get buy-in from QA lead and dev lead

#### For QA Lead
1. Review test data file formats (Excel/CSV/JSON/YAML)
2. Confirm Excel is acceptable for test data entry
3. Identify QA team members who will create test data
4. Review validation requirements (HTTP 200 + element + no errors)

#### For Dev Lead
1. Review architecture and components
2. Confirm implementation timeline (5 weeks)
3. Assign developer(s) for implementation
4. Confirm no conflicts with existing framework features

#### For Framework Architect
1. Ensure hybrid approach fits with existing framework patterns
2. Review data models and component design
3. Confirm no architectural concerns
4. Approve or request changes

---

### Success Criteria

The implementation will be considered successful when:

âœ… **Functionality**
- [ ] QA team can create URL test cases using Excel
- [ ] Developers can use YAML config for auto-generation
- [ ] Auto-detect mode works correctly
- [ ] All 4 URL formats supported (query string, path-param, etc.)
- [ ] Comprehensive validation catches issues

âœ… **Quality**
- [ ] 90%+ unit test coverage
- [ ] 100% integration test coverage
- [ ] No breaking changes to existing tests
- [ ] Documentation complete and accurate

âœ… **Adoption**
- [ ] At least 10 Bookslot tests using manual mode (Excel)
- [ ] At least 5 Bookslot tests using auto mode (config)
- [ ] QA team trained and comfortable with Excel approach
- [ ] Developers trained on config-driven approach

âœ… **Performance**
- [ ] Test data loading < 1 second
- [ ] URL generation < 5 seconds for 1000 combinations
- [ ] Validation < 10 seconds per URL
- [ ] No performance regression in existing tests

---

### Sample Test Data Files to Create

#### 1. bookslot_testdata.xlsx (Manual Mode)
**Location**: `test_data/bookslot/bookslot_testdata.xlsx`  
**Content**: 20+ URL test cases for Bookslot project  
**Owner**: QA Team  
**Format**: Excel with columns: workflow_id, environment, language, source, patient_type, etc.

#### 2. bookslot_urls.yaml (Auto Mode - Fallback)
**Location**: `config/url_testing/bookslot_urls.yaml`  
**Content**: Config for auto-generation (workflow IDs, parameters, rules)  
**Owner**: Dev Team  
**Format**: YAML with environments, workflow_ids, query_parameters

#### 3. Example Templates
**Location**: `test_data/templates/`  
**Content**: Empty templates for QA team to copy  
**Files**:
- `url_testdata_template.xlsx`
- `url_testdata_template.csv`
- `url_testdata_template.json`
- `url_testdata_template.yaml`

---

### Risk Mitigation

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **Excel file corruption** | MEDIUM | HIGH | Version control CSV backup, use OneDrive auto-save |
| **QA team unfamiliar with Excel data entry** | LOW | MEDIUM | Training session, clear templates, examples |
| **Complex URL formats break** | LOW | MEDIUM | Comprehensive unit tests, validation before test run |
| **Mode detection fails** | LOW | HIGH | Fallback to auto-detect, clear error messages |
| **Performance issues with large datasets** | MEDIUM | MEDIUM | Lazy loading, pagination, caching |
| **Breaking existing tests** | LOW | HIGH | Backward compatibility, gradual migration |

---

## âœ… Approval & Sign-off

| Role | Name | Approval | Date | Comments |
|------|------|----------|------|----------|
| **Framework Architect** | _Pending_ | â³ | _TBD_ | Hybrid approach review needed |
| **QA Lead** | _Pending_ | â³ | _TBD_ | Confirm Excel-based test data acceptable |
| **Dev Lead** | _Pending_ | â³ | _TBD_ | Confirm 5-week timeline acceptable |
| **Project Owner (Bookslot)** | _Pending_ | â³ | _TBD_ | Final approval for implementation |

---

## ğŸ“ Contact & Feedback

**Questions or Feedback?**  
Please discuss this revised design document and provide your input before implementation begins.

**Key Questions for Stakeholders:**
1. Is the hybrid approach (manual + auto) acceptable?
2. Is Excel the right format for QA team test data entry?
3. Is the 5-week implementation timeline acceptable?
4. Any concerns about the comprehensive validation approach?
5. Any missing requirements or features?

---

## ğŸ“š Related Documents

- [Quick Reference Guide](./URL_TESTING_QUICK_REFERENCE.md)
- [Framework Architecture](../Framework-Knowledge-Center/)
- [Test Data Management Guidelines](../04-Test-Data-Management/)

---

## ğŸ“ Document Changelog

### Version 2.0 (February 19, 2026)
- **MAJOR UPDATE**: Revised to data-driven hybrid approach based on user feedback
- Added Test Data Loader component (Excel/CSV/JSON/YAML support)
- Added URL Data Manager component (mode detection, routing)
- Added comprehensive gap analysis section
- Updated requirements to reflect 2 environments only
- Changed validation to comprehensive (Level 4)
- Added support for multiple URL formats (future-proof)
- Updated implementation timeline to 5 weeks
- Added detailed migration path
- Added risk mitigation section

### Version 1.0 (February 19, 2026)
- Initial design (config-driven approach)
- Requirements analysis
- Architecture design
- Data structure design
- Implementation approaches comparison
- Usage patterns
- Migration path

---

**Document Version**: 2.0 (REVISED - HYBRID APPROACH)  
**Last Updated**: February 19, 2026
**Status**: â³ Awaiting Approval  
**Next Review Date**: February 21, 2026  
**Approved Implementation Start**: TBD

---

## ğŸ¯ TL;DR - Executive Summary

### What Changed from V1.0 to V2.0?

**Original Design (V1.0):**
- Config-driven (YAML only)
- Auto-generation primary
- Developers edit config files
- Single mode (auto)

**Revised Design (V2.0 - THIS VERSION):**
- Data-driven hybrid (Test data files + Config fallback)
- Manual test data primary, auto-generation secondary
- QA team uses Excel, developers use YAML
- Multiple modes (manual, auto, auto-detect)

### Why the Change?

User feedback revealed:
1. Team has test data in Excel files (not config)
2. Workflow IDs and parameters provided manually (not auto-generated)
3. Only 2 environments needed (not 3+)
4. Need comprehensive validation (HTTP 200 + element + no errors)
5. Need flexibility for future URL formats

### Key Benefits of Revised Approach

âœ… **87% faster** test data creation (Excel vs YAML)  
âœ… **5x more people** can create tests (entire QA team vs 2 devs)  
âœ… **4 data formats** supported (Excel, CSV, JSON, YAML)  
âœ… **3 modes** for flexibility (manual, auto, auto-detect)  
âœ… **Comprehensive validation** catches more issues  
âœ… **Future-proof** for new URL formats  

### Bottom Line

**Approve this revised design** to get a more flexible, QA-friendly, and future-proof URL testing system that meets the actual project needs (data-driven, not config-driven).

**Implementation Time**: 5 weeks  
**Risk**: LOW (backward compatible, gradual migration)  
**ROI**: HIGH (faster test creation, more contributors, better quality)

---

**END OF DOCUMENT**  
