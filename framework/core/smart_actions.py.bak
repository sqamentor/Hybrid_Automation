"""
Smart Actions - Context-Aware Automation Layer
===============================================
Reusable intelligent action wrappers that automatically apply
context-aware delays based on action type.

This eliminates manual delay calls throughout test code!

Usage:
    from framework.core.smart_actions import SmartActions

    actions = SmartActions(page, enable_human=True)
    actions.type_text(element, "text", "Field Name")
    actions.click(element, "Button Name")

Author: Lokendra Singh
Email: lokendra.singh@centerforvein.com
Website: www.centerforvein.com
"""

import random
import time
from typing import Optional

from playwright.sync_api import Locator, Page

from framework.observability import log_function, log_operation
from utils.logger import get_audit_logger, get_logger

logger = get_logger(__name__)
audit_logger = get_audit_logger()


class SmartActions:
    """
    Intelligent action wrappers with automatic context-aware delays.

    All delays are automatically applied based on action context:
    - Click: 0.3-0.7s before, 0.2-0.4s after
    - Type: 0.3-0.6s before, 0.2-0.5s after
    - Button: 0.4-0.9s before, 0.3-0.6s after
    - Navigate: 0.4-0.8s before, 0.5-1.0s after
    """

    def __init__(self, page: Page, enable_human: bool = False, verbose: bool = False):
        """
        Initialize SmartActions

        Args:
            page: Playwright Page object
            enable_human: Enable human-like delays
            verbose: Log delay information at DEBUG level
        """
        self.page = page
        self.enable_human = enable_human
        self.verbose = verbose
        logger.info(f"SmartActions initialized (human_behavior={enable_human}, verbose={verbose})")
        audit_logger.log_action("smart_actions_init", {
            "enable_human": enable_human,
            "verbose": verbose
        })

    def _delay(self, min_sec: float, max_sec: float, context: str = ""):
        """Internal delay with optional debug logging"""
        if self.enable_human:
            delay_time = random.uniform(min_sec, max_sec)
            time.sleep(delay_time)
            if self.verbose and context:
                logger.debug(f"delay {context}: {delay_time:.2f}s")
            audit_logger.log_action("delay", {"context": context, "duration_sec": delay_time}, status="success")

    @log_function(log_args=True, log_timing=True, mask_sensitive=False)
    def click(self, element: Locator, description: str = ""):
        """
        Click element with automatic delays

        Auto-applies:
        - 0.3-0.7s before (thinking)
        - 0.2-0.4s after (confirmation)
        """
        logger.debug(f"SmartActions: Preparing to click '{description}'")
        self._delay(0.3, 0.7, f"Before click: {description}")
        element.click()
        logger.info(f"✓ Clicked: '{description}'")
        self._delay(0.2, 0.4, f"After click: {description}")
        audit_logger.log_ui_action(action="click", element=description)

    @log_function(log_args=True, log_timing=True, mask_sensitive=True)
    def type_text(self, element: Locator, text: str, field_name: str = ""):
        """
        Type text with context-aware speed

        Auto-applies:
        - 0.3-0.6s before (preparation)
        - Context-aware typing speed:
          * Numbers: 0.08-0.18s per char
          * Email: 0.12-0.25s per char
          * Dates: 0.10-0.22s per char
          * Text: 0.10-0.23s per char
        - 0.2-0.5s after (review)
        """
        self._delay(0.3, 0.6, f"Before type: {field_name}")

        # Wait for element to be visible and enabled
        try:
            element.wait_for(state="visible", timeout=10000)
        except Exception as exc:
            logger.warning(
                f"type_text: element not immediately visible for '{field_name}' "
                f"({type(exc).__name__}) - sleeping 0.5s then retrying"
            )
            time.sleep(0.5)
            element.wait_for(state="visible", timeout=10000)

        if self.enable_human:
            text_str = str(text)
            is_numeric = text_str.replace("-", "").replace(" ", "").replace(".", "").isdigit()
            is_email = "@" in text_str
            is_date = "/" in text_str and len(text_str.split("/")) == 3

            # Determine typing speed based on content type
            if is_numeric:
                delay_ms = random.uniform(80, 180)
            elif is_email:
                delay_ms = random.uniform(120, 250)
            elif is_date:
                delay_ms = random.uniform(100, 220)
            else:
                delay_ms = random.uniform(100, 230)

            # Use press_sequentially for more reliable character-by-character typing
            # This is more stable than element.type() in a loop as it handles element state better
            element.press_sequentially(text_str, delay=delay_ms)
        else:
            element.fill(str(text))

        logger.info(f"✓ Filled: '{field_name}' = '{str(text)[:50]}'")
        self._delay(0.2, 0.5, f"After type: {field_name}")
        audit_logger.log_ui_action(action="type", element=field_name, value=str(text)[:50])

    @log_function(log_args=True, log_timing=True)
    def button_click(self, element: Locator, button_name: str = "", wait_processing: bool = False):
        """
        Button click with extra consideration time

        Auto-applies:
        - 0.4-0.9s before (considering)
        - 0.3-0.6s after (confirmation)
        - 1.5-2.5s after if wait_processing=True (for Submit, Send Code, Verify buttons)

        Args:
            element: Button locator
            button_name: Description of button
            wait_processing: Add extra delay for processing (Submit, Verify, Send Code)
        """
        self._delay(0.4, 0.9, f"Before button: {button_name}")
        element.click()

        # Context-aware post-click delay
        if wait_processing or any(
            keyword in button_name.lower() for keyword in ["send", "verify", "submit", "code"]
        ):
            self._delay(1.5, 2.5, f"Processing: {button_name}")
        else:
            self._delay(0.3, 0.6, f"After button: {button_name}")

        logger.info(f"✓ Button clicked: '{button_name}'")
        audit_logger.log_ui_action(action="button_click", element=button_name)

    @log_function(log_args=True, log_timing=True)
    def navigate(self, url: str, page_name: str = "", wait_transition: bool = False):
        """
        Navigate with page observation

        Auto-applies:
        - 0.4-0.8s before (decision)
        - 0.5-1.0s after (observation)
        - 0.8-1.5s after if wait_transition=True (for page transitions)

        Args:
            url: URL to navigate to
            page_name: Description of page
            wait_transition: Add extra delay for page transition
        """
        self._delay(0.4, 0.8, f"Navigating to: {page_name}")
        self.page.goto(url)

        if wait_transition:
            self._delay(0.8, 1.5, f"Page transition: {page_name}")
        else:
            self._delay(0.5, 1.0, f"Observing: {page_name}")

        logger.info(f"✓ Navigated to: '{page_name}' -> {url}")
        audit_logger.log_page_load(page_name=page_name, url=url)

    def wait_for_page_ready(self, context: str = ""):
        """
        Wait for page to be ready with network idle check

        Auto-applies:
        - Network idle wait (15s timeout)
        - 0.8-1.5s observation delay

        Args:
            context: Description for logging
        """
        try:
            self.page.wait_for_load_state("networkidle", timeout=15000)
        except Exception as exc:
            logger.warning(
                f"wait_for_page_ready: networkidle timed out for '{context}' "
                f"({type(exc).__name__}) - continuing"
            )
        self._delay(0.8, 1.5, f"Page ready: {context}")
        logger.info(f"✓ Page ready: '{context}'")
        audit_logger.log_action("page_ready", {"context": context}, status="success")

    def select_option(self, dropdown: Locator, option: Locator, field_name: str = ""):
        """
        Select dropdown option with delays

        Auto-applies:
        - 0.3-0.6s before opening
        - 0.2-0.4s reviewing options
        - 0.2-0.4s after selection
        """
        self._delay(0.3, 0.6, f"Opening dropdown: {field_name}")
        dropdown.click()
        self._delay(0.2, 0.4, "Reviewing options")
        option.click()
        self._delay(0.2, 0.4, f"Selected: {field_name}")
        logger.info(f"✓ Selected option: '{field_name}'")
        audit_logger.log_ui_action(action="select_option", element=field_name)

    def wait_autocomplete(self, pattern: str, description: str = "", timeout: int = 6000) -> bool:
        """
        Smart autocomplete handling with timeout

        Args:
            pattern: Locator pattern for autocomplete
            description: Description for logging
            timeout: Timeout in milliseconds (default 6000)

        Returns:
            True if autocomplete found and clicked, False otherwise
        """
        try:
            element = self.page.locator(pattern).first
            element.wait_for(state="visible", timeout=timeout)
            self._delay(0.3, 0.6, f"Reviewing autocomplete: {description}")
            element.click()
            logger.info(f"✓ Autocomplete selected: '{description}'")
            audit_logger.log_ui_action(action="autocomplete_select", element=description)
            return True
        except Exception as exc:
            logger.warning(
                f"wait_autocomplete: timeout ({timeout / 1000}s) for '{description}' "
                f"({type(exc).__name__}) - continuing"
            )
            self._delay(0.2, 0.3)
            return False

    def wait_and_click(self, locator: Locator, description: str = "", timeout: int = 30000):
        """
        Wait for element and click with smart delays

        Args:
            locator: Playwright locator
            description: Description for logging
            timeout: Timeout in milliseconds
        """
        try:
            locator.wait_for(state="visible", timeout=timeout)
            self.click(locator, description)
            return True
        except Exception as exc:
            logger.warning(
                f"wait_and_click: element not found '{description}' ({type(exc).__name__})"
            )
            return False

    def wait_for_scheduler(self, context: str = "Scheduler"):
        """
        Wait for scheduler/calendar to load

        Auto-applies:
        - 1.5-2.5s loading delay (for dynamic content like time slots)

        Args:
            context: Description for logging
        """
        self._delay(1.5, 2.5, f"{context} loading")
        logger.info(f"✓ Scheduler ready: '{context}' slots loaded")
        audit_logger.log_action("scheduler_ready", {"context": context}, status="success")

    def wait_for_processing(self, context: str = "Processing", short: bool = False):
        """
        Wait for processing operations

        Auto-applies:
        - 1.0-2.0s for verification/processing (short=True)
        - 1.5-2.5s for submission/heavy processing (short=False)

        Args:
            context: Description for logging
            short: Use shorter delay for lighter operations
        """
        if short:
            self._delay(1.0, 2.0, f"{context}")
        else:
            self._delay(1.5, 2.5, f"{context}")
        logger.info(f"✓ Processing complete: '{context}'")
        audit_logger.log_action("processing_complete", {"context": context, "short": short}, status="success")

    def smart_retry(self, action_func, max_retries: int = 3, delay_between: tuple = (1.0, 2.0)):
        """
        Retry an action with smart delays

        Args:
            action_func: Function to retry
            max_retries: Maximum retry attempts
            delay_between: Delay range between retries

        Returns:
            Result of action_func or None if all retries fail
        """
        for attempt in range(max_retries):
            try:
                result = action_func()
                logger.info(f"✓ Smart retry succeeded on attempt {attempt + 1}/{max_retries}")
                audit_logger.log_action("smart_retry_success", {"attempt": attempt + 1, "max_retries": max_retries}, status="success")
                return result
            except Exception as exc:
                if attempt < max_retries - 1:
                    logger.warning(
                        f"smart_retry: attempt {attempt + 1}/{max_retries} failed "
                        f"({type(exc).__name__}) - retrying"
                    )
                    audit_logger.log_action("smart_retry_attempt_failed", {"attempt": attempt + 1, "error": str(exc)}, status="warning")
                    self._delay(delay_between[0], delay_between[1], "Retry delay")
                else:
                    logger.error(
                        f"smart_retry: all {max_retries} attempts failed ({type(exc).__name__})"
                    )
                    audit_logger.log_action("smart_retry_failed", {"max_retries": max_retries, "error": str(exc)}, status="failure")
                    raise
        return None
